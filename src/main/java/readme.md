# 软件设计模式

## 设计目的： 松耦合，高内聚
## 七大原则：
* 单一职责原则
    * 一个类只负责一个职责
* 接口隔离原则
    * 客户端不应该依赖它不需要的接口
    * 即依赖的接口应该是范围（接口的方法刚好都被客户端用到）最小的
* 依赖倒转原则
    * 面向接口编程
    * 模块都依赖接口，细节依赖接口
* 里氏替换原则
    * 子类尽量不要重写父类方法
    * 因为继承容易造成增强耦合，所以尽量通过组合方式（两个类继承同一个，实现同一个）来避免单个继承（单个继承容易重写方法）
* 开闭原则（最基本重要的原则）
    * 对扩展开发（提供方），对修改关闭（使用方）
    * 当软件需要变化时，尽量通过扩展软件实体，而不是修改代码
* 迪米特法则（也称 最少知道法则）
    * 对象之间保持最少的了解 因为类关系越密切，耦合度越大
    * 逻辑封装在内部，只对外提供public方法
* 合成复用原则
    * 为了松耦合，尽量少用继承，而用聚合，合成（当B类 想用 A类方法，让B使用A类对象）
    
## 模式的种类
   
   * 创建型模式(共五种)：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
   
   * 结构型模式(共七种)：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
   
   * 行为型模式(共十一种)：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
   
## Spring框架中都用到了哪些设计模式，并举例说明？
   
   * 工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
   * 代理设计模式 : Spring AOP 功能的实现。
   * 单例设计模式: Spring 中的 Bean 默认都是单例的。
   * 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
   * 观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。
   * 适配器模式:Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。    
    
## 二十三种设计模式
#### 1单例模式
某个类中只能存在一个对象实例，而且获取对象的方法也只能有一个 

#### 2简单工厂模式(一般不放在23种模式中）
创建对象的动作封装到一个工厂类中，这样有新的种类时，就只修改该类就行（各个种类，奶油，芝士等等）

#### 3工厂模式
定义了创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类
eg：BeijingPizza 继承 抽象类OrderPizza，BeijingPizza（里面写各个种类的pizza）实现createpizza抽象方法，


#### 4抽象工厂模式
定义Interface的Factory，在orderPizza中聚合pizza类（创建pizza对象（有各个种类））

* 三种工厂模式的小结：
    * 实例化对象的代码提取出来，放到一个类中，统一管理
    * 设计模式的依赖抽象原则（创建对象实例，不要直接new类，而是把这个new类的动作放在一个工厂中

#### 5原型模式
用原型实例指定创建对象的种类，并且通过实现Cloneable中的clone（）方法，来拷贝创建对象(属性相同，但是对象不相等)

#### 6建造者模式
可以将复杂对象的建造过程抽象化（写成抽象类+抽象方法（不同的建造过程））

#### 7适配器模式
（Adapter）某个类的接口转换成客户端服务的另一接口，目的是兼容。
* 分为三种适配器：
    * 类适配器：Adapter类 继承服务端类 实现客户端类（eg：电压Adapter 继承220V 实现5V) 
    * 对象适配器：Adapter类 实现客户端类（和类适配器思想一样，实现方式不同），将服务端类的对象放入该Adapter类中
    * 接口适配器：将Adapter类抽象化 再实现接口类
    
#### 8桥接模式
将实现和抽象放在两个类层次中（一个接口一个抽象），基于类的最小设计原则
eg：Phone p1 = new FlodedPhone(new Xiaomi()) 得到折叠式小米手机 小米实现品牌，折叠式继承手机

#### 9装饰者模式
通过使用继承，动态的将新功能附加功能上，符合开闭原则（ocp），适合不断为对象加包装
eg：A类coffee为5元，加奶沫+2元，+浓缩+10元。改成B类咖啡，只需要写个B类继承Coffee

#### 10组合模式
通过让A1，A2等等都继承OrganizationCompoent,创建对象组的树形结构，来表示整体-部分层次

#### 11外观模式
为子系统中的多个接口提供一个界面，定义为高层接口，用来屏蔽子系统的细节，使得调用端只需跟接口关联，而无需关系这个子系统的内部细节

#### 12享元模式
共享对象的模式，解决重复对象的内存浪费问题，经典应用场景是池技术（String常量池，数据库连接池，缓冲池技术）


#### 13代理模式
提供替身，增强额外的功能操作，扩展功能
被代理的对象可以是**远程对象，创建开销大的对象，需要安全控制的对象**
* 代理形式：
    * 静态代理：需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者继承相同父类
    * 动态代理：不需要实现接口，但目标对象要实现接口，利用jdk的API，动态的在内存中构建代理对象（java.lang.reflect.Proxy 的 new ProxyInstance方法）
    * Cglib代理：目标对象可以没有实现任何接口，在内存中构建子类对象，实现对功能的扩展。（如Spring的 AOP）

#### 14模板模式
在一个抽象类中，定义了执行它的方法的模板，调用方继承抽象类并重写其中的少量方法（其他方法保持不变）
* 钩子方法：额外为一个方法A写的boolean方法，来判断是否要执行方法A

#### 15命令模式
使得请求发送者和接受者消除彼此之间的耦合，不需要了解操作的具体实现过程

#### 16访问者模式
封装作用域数据结构的操作（添加，删除元素等），可以在不改变数据结构的前台定义出新操作
eg：对访问的类，提供一个统一对外访问的接口，可以用集合来管理对象。

#### 17迭代器模式
提供一种遍历集合元素的统一接口（实现java.util.Iterator)，不暴露出内部的结构

#### 18观察者模式
对象多对一（多个观察者Observer，一个服务中心Subject），Subject notify Observer，Subject有注册，移除，通知observer的方法。

#### 19中介者模式
用一个中介对象封装一系列对象，使对象间不需要显示的相互引用，如M是MVC中的中介

#### 20备忘录模式
用集合封装对象的各个状态，可用于回退对象状态
eg：游戏关卡的存储

#### 21解释器模式
定义一个解释器，来解释某一种语言或者表达式
eg：计算器计算，正则表达式，机器人

#### 22状态模式
解决对象在多种状态转换时，要对外输出不同的行为。状态和行为一一对应

#### 23策略模式
定义算法族，可以相互替换。客户直接使用想要的对象和其方法，对于不同对象的同一方法，实现多变性

#### 24职责链模式
创建一个关于处理者对象的链，一个对象符合时会将请求传给下一个处理者。
eg：OA系统中，根据订单大小，让CEO，财务，HR等审批

#### 没有啦，完结撒花！
