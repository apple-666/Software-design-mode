# 软件设计模式

## 设计目的： 松耦合，高内聚
## 七大原则：
* 单一职责原则
    * 一个类只负责一个职责
* 接口隔离原则
    * 客户端不应该依赖它不需要的接口
    * 即依赖的接口应该是范围（接口的方法刚好都被客户端用到）最小的
* 依赖倒转原则
    * 面向接口编程
    * 模块都依赖接口，细节依赖接口
* 里氏替换原则
    * 子类尽量不要重写父类方法
    * 因为继承容易造成增强耦合，所以尽量通过组合方式（两个类继承同一个，实现同一个）来避免单个继承（单个继承容易重写方法）
* 开闭原则（最基本重要的原则）
    * 对扩展开发（提供方），对修改关闭（使用方）
    * 当软件需要变化时，尽量通过扩展软件实体，而不是修改代码
* 迪米特法则（也称 最少知道法则）
    * 对象之间保持最少的了解 因为类关系越密切，耦合度越大
    * 逻辑封装在内部，只对外提供public方法
* 合成复用原则
    * 为了松耦合，尽量少用继承，而用聚合，合成（当B类 想用 A类方法，让B使用A类对象）
    
## 二十三中设计模式
#### 1单例模式
某个类中只能存在一个对象实例，而且获取对象的方法也只能有一个 

#### 2简单工厂模式
创建对象的动作封装到一个工厂类中，这样有新的种类时，就只修改该类就行（各个种类，奶油，芝士等等）

#### 3工厂模式
定义了创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类
eg：BeijingPizza 继承 抽象类OrderPizza，BeijingPizza（里面写各个种类的pizza）实现createpizza抽象方法，


#### 4抽象工厂模式
定义Interface的Factory，在orderPizza中聚合pizza类（创建pizza对象（有各个种类））

* 三种工厂模式的小结：
    * 实例化对象的代码提取出来，放到一个类中，统一管理
    * 设计模式的依赖抽象原则（创建对象实例，不要直接new类，而是把这个new类的动作放在一个工厂中

#### 5原型模式
用原型实例指定创建对象的种类，并且通过实现Cloneable中的clone（）方法，来拷贝创建对象(属性相同，但是对象不相等)

#### 6建造者模式
可以将复杂对象的建造过程抽象化（写成抽象类+抽象方法（不同的建造过程））

#### 7适配器模式
（Adapter）某个类的接口转换成客户端服务的另一接口，目的是兼容。
* 分为三种适配器：
    * 类适配器：Adapter类 继承服务端类 实现客户端类（eg：电压Adapter 继承220V 实现5V) 
    * 对象适配器：Adapter类 实现客户端类（和类适配器思想一样，实现方式不同），将服务端类的对象放入该Adapter类中
    * 接口适配器：将Adapter类抽象化 再实现接口类
    
#### 8桥接模式
将实现和抽象放在两个类层次中（一个接口一个抽象），基于类的最小设计原则
eg：Phone p1 = new FlodedPhone(new Xiaomi()) 得到折叠式小米手机 小米实现品牌，折叠式继承手机

#### 9装饰者模式
通过使用继承，动态的将新功能附加功能上，符合开闭原则（ocp），适合不断为对象加包装
eg：A类coffee为5元，加奶沫+2元，+浓缩+10元。改成B类咖啡，只需要写个B类继承Coffee

#### 10组合模式
通过让A1，A2等等都继承OrganizationCompoent,创建对象组的树形结构，来表示整体-部分层次

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

#### 3工厂模式

